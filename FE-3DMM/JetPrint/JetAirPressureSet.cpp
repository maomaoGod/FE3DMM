#include "StdAfx.h"
#include "JetAirPressureSet.h"

#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#include <math.h>
unsigned char buff[256];
unsigned char buff2[256];

const unsigned char m_auchCRCHi[]=
{
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
	0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
	0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,
	0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,
	0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
	0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,
	0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
	0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
	0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
	0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
	0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
	0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,
	0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
	0x80,0x41,0x00,0xC1,0x81,0x40 
};

const unsigned char m_auchCRCLo[]=
{
	0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,
	0x07,0xC7,0x05,0xC5,0xC4,0x04,0xCC,0x0C,0x0D,0xCD,
	0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,
	0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,
	0x1E,0xDE,0xDF,0x1F,0xDD,0x1D,0x1C,0xDC,0x14,0xD4,
	0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,
	0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,
	0xF2,0x32,0x36,0xF6,0xF7,0x37,0xF5,0x35,0x34,0xF4,
	0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,
	0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,
	0xEB,0x2B,0x2A,0xEA,0xEE,0x2E,0x2F,0xEF,0x2D,0xED,
	0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
	0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,
	0x61,0xA1,0x63,0xA3,0xA2,0x62,0x66,0xA6,0xA7,0x67,
	0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,
	0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,
	0x78,0xB8,0xB9,0x79,0xBB,0x7B,0x7A,0xBA,0xBE,0x7E,
	0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,
	0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,
	0x70,0xB0,0x50,0x90,0x91,0x51,0x93,0x53,0x52,0x92,
	0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
	0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,
	0x99,0x59,0x58,0x98,0x88,0x48,0x49,0x89,0x4B,0x8B,
	0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
	0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,
	0x43,0x83,0x41,0x81,0x80,0x40 
};
CJetAirPressureSet::CJetAirPressureSet(void)
{
	m_enumAnalogType = EMPTY_TYPE;
}


CJetAirPressureSet::~CJetAirPressureSet(void)
{
}

BOOL CJetAirPressureSet::Init( unsigned long xPort,/*串口号 */
	                        unsigned long xBabd /*= 9600*/,/*波特率 */ 
							unsigned char xDataSize /*= 8*/, /*数据位*/ 
							unsigned char xParity /*= 0*/,/*校验位*/ 
							unsigned char xStopBit /*= 0*/ )/*停止位*/ 
{
	//打开串口
	if(FALSE == m_comm.OpenPort(xPort,xBabd,xDataSize,xParity,xStopBit,4096,4096,1000))
	{
		return FALSE;
	}
	//检测通信
	if(FALSE == CheckConnect())
	{
		return FALSE;
	}

	return TRUE;
}

BOOL CJetAirPressureSet::UnInit()
{
	if (m_comm.IsOpen())
	{
		m_comm.ClosePort();
	}
	return TRUE;
}


BOOL CJetAirPressureSet::WriteData(unsigned char regLoc_H, unsigned char regLoc_L, float val, AnalogType analogtype)
{
	unsigned short int crc16;
	unsigned short int crctmp;
	unsigned short int vol_ox = 0;
	unsigned short int temp;
	
	memset(buff2, 0x00, 255);
	buff2[0] = 0x01;
	buff2[1] = 0x06;
	buff2[2] = regLoc_H;
	buff2[3] = regLoc_L;

	//计算电压值并转换成16进制数
	switch(analogtype)
	{
	case EMPTY_TYPE:
		vol_ox = static_cast<unsigned short>(val);
		break;
	case MA_0_20:
		val = val < 0 ? 0 : (val > 20 ? 20 : val);
		vol_ox = static_cast<unsigned short>(val * 4096 / 20);
		break;
	case MA_4_20:
		val = val < 4 ? 4 : (val > 20 ? 20 : val);
		vol_ox = static_cast<unsigned short>(val * 4096 / 20);
		break;
	case V_0_5:
		val = val < 0 ? 0 : (val > 5 ? 5 : val);
		vol_ox = static_cast<unsigned short>(val * 4096 / 5);
		break;
	case V_0_10:
		val = val < 0 ? 0 : (val > 10 ? 10 : val);
		vol_ox = static_cast<unsigned short>(val * 4096 / 10);
		break;
	default:
		break;
	}

	temp = vol_ox & 0xFF00;   //取高8位
	temp = temp >> 8;    
	buff2[4] = temp;

	temp = vol_ox & 0x00FF; //取低8位
	buff2[5] = temp;

	//计算校验位
	crc16 = CalcCrcFast(buff2,6);
	buff2[6] = (unsigned char)(crc16 >> 8);
	buff2[7] = (unsigned char)crc16;

	//发送数据
	unsigned long strlen;
	if(FALSE == m_comm.IsOpen())
	{
		return FALSE;
	}
	
	//发送数据
	strlen = m_comm.WriteChar(8,(char*)buff2);
	if(strlen != 8)
	{
		return FALSE;
	}
	
	//读数据
	memset(buff2, 0x00, 255);
	Sleep(50);

	strlen= m_comm.ReadChar(255, (char *)buff2, 1000);
	if(strlen == 0)
	{
		return FALSE;				
	}

	//返回长度有效,解析接收缓冲区
	if(buff2[0] != 0x01 || buff2[1] != 0x06) 
	{
		return FALSE;
	}
	crc16= CalcCrcFast(buff2, 6);
	crctmp= buff2[strlen-2];
	crctmp= crctmp << 8 | buff2[strlen-1];
	if(crc16 != crctmp )
	{
		return FALSE;
	}
	
	return TRUE;
}


BOOL CJetAirPressureSet::WriteData(int channel, float val)
{
	BOOL res = FALSE;
	switch(channel)
	{
	case 0:
		res = WriteData(0x00, 0x30, val, m_enumAnalogType);
		break;
	case 1:
		res = WriteData(0x00, 0x31, val, m_enumAnalogType);
		break;
	case 2:
		res = WriteData(0x00, 0x32, val, m_enumAnalogType);
		break;
	case 3:
		res = WriteData(0x00, 0x33, val, m_enumAnalogType);
		break;
	default: 
		break;
	}

	return res;
}


BOOL CJetAirPressureSet::ReadData(unsigned char regLoc_H, unsigned char regLoc_L, float *pVal, AnalogType analogtype)
{
	unsigned short int crc16;
	unsigned short int crctmp;
	unsigned short int RegCount = 1;

	unsigned short int datal;
	unsigned short int datah;
	float vlotage = 0.0;

	memset(buff, 0x00, 255);
	buff[0] = 0x01;
	buff[1] = 0x04;
	buff[2] = regLoc_H;
	buff[3] = regLoc_L;
	buff[4] = 0x00;
	buff[5] = 0x01;

	//计算校验位
	crc16 = CalcCrcFast(buff, 6);
	buff[6] = (unsigned char)(crc16 >> 8);
	buff[7] = (unsigned char)crc16;

	//发送数据
	unsigned long strlen;
	if(FALSE == m_comm.IsOpen())
	{
		return FALSE;
	}

	//发送数据
	strlen = m_comm.WriteChar(8, (char*)buff);
	if(strlen != 8)
	{
		return FALSE;
	}

	//读数据
	memset(buff, 0x00, 255);
	Sleep(50);
	strlen= m_comm.ReadChar(255, (char *)buff, 1000);
	if(strlen == 0)
	{
		return FALSE;				
	}

	//返回长度有效,解析接收缓冲区
	if(strlen != (3+(RegCount*2)+2) || buff[0] != 0x01 || buff[1] != 0x04)
	{
		return FALSE;
	}
	crc16= CalcCrcFast(buff, 3+(RegCount*2));
	crctmp= buff[strlen-2];
	crctmp= crctmp << 8 | buff[strlen-1];
	if(crc16 != crctmp )
	{
		return FALSE;
	}

	datal = buff[4];
	datah = buff[3];
	datah = datah<<8;
	switch(analogtype)
	{
	case EMPTY_TYPE:
		vlotage = (float)(datah+datal);
		break;
	case MA_0_20:
		vlotage = (float)(datah+datal) * 20 / 4096;
		break;
	case MA_4_20:
		vlotage = (float)(datah+datal) * 20 / 4096;
		break;
	case V_0_5:
		vlotage = (float)(datah+datal) * 5 / 4096;
		break;
	case V_0_10:
		vlotage = (float)(datah+datal) * 10 / 4096;
		break;
	default:
		break;
	}
	*pVal = vlotage;    //测量值

	return TRUE;
}


BOOL CJetAirPressureSet::ReadData(int channel, float *pVal)
{
	BOOL res = FALSE;
	switch(channel)
	{
	case 0:
		res = ReadData(0x00, 0x00, pVal, m_enumAnalogType);
		break;
	case 1:
		res = ReadData(0x00, 0x01, pVal, m_enumAnalogType);
		break;
	case 2:
		res = ReadData(0x00, 0x02, pVal, m_enumAnalogType);
		break;
	case 3:
		res = ReadData(0x00, 0x03, pVal, m_enumAnalogType);
		break;
	default: 
		break;
	}
	
	return res;
}


BOOL CJetAirPressureSet::CheckConnect()
{
	unsigned short int crc16;

	memset(buff, 0x00, 255);

	buff[0]= 0x01;
	buff[1]= 0x03;
	buff[2]= 0x00;
	buff[3]= 0x40;
	buff[4]= 0x00;
	buff[5]= 0x10;
	crc16= CalcCrcFast(buff, 6);
	buff[6]= (unsigned char)(crc16 >> 8);
	buff[7]= (unsigned char)crc16;

	
	//检查串口是否打开
	if(FALSE == m_comm.IsOpen())
	{
		return FALSE;
	}

	//发送数据
	if(8 != m_comm.WriteChar(8, (char *)buff))
	{
		return FALSE;
	}

	//读数据
	memset(buff, 0x00, 255);
	Sleep(100);

	unsigned long strlen = m_comm.ReadChar(255, (char *)buff,1000);
		
	//计算返回长度是否正确
	if(strlen != (3+(16*2)+ 2))
	{
		return FALSE;
	}
				
	return TRUE;
}


unsigned short CJetAirPressureSet::CalcCrcFast(unsigned char*puchMsg,unsigned short usDataLen)
{
	unsigned char uchCRCHi=0xFF ;
	unsigned char uchCRCLo=0xFF ;
	unsigned short uIndex ;

	while(usDataLen--)
	{
		uIndex=uchCRCHi^*puchMsg++;
		uchCRCHi=uchCRCLo^m_auchCRCHi[uIndex];
		uchCRCLo=m_auchCRCLo[uIndex];
	}
	return(uchCRCHi<<8|uchCRCLo);
}


BOOL CJetAirPressureSet::SetAnalogInputType(int type)
{
	BOOL res = FALSE;
	switch(type)
	{
	case 0:
		m_enumAnalogType = MA_0_20;
		res = WriteData(0x00, 0x4B, 0, EMPTY_TYPE);
		break;
	case 1:
		m_enumAnalogType = MA_4_20;
		res = WriteData(0x00, 0x4B, 1, EMPTY_TYPE);
		break;
	case 2:
		m_enumAnalogType = V_0_5;
		res = WriteData(0x00, 0x4B, 2, EMPTY_TYPE);
		break;
	case 3:
		m_enumAnalogType = V_0_10;
		res = WriteData(0x00, 0x4B, 3, EMPTY_TYPE);
		break;
	default: 
		break;
	}

	return res;
}